"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generatorSchematic = exports.generatorGenerator = exports.createGeneratorsJson = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const path = require("path");
const has_generator_1 = require("../../utils/has-generator");
const generator_1 = require("../lint-checks/generator");
function normalizeOptions(host, options) {
    const { npmScope } = (0, devkit_1.getWorkspaceLayout)(host);
    const { root: projectRoot, sourceRoot: projectSourceRoot } = (0, devkit_1.readProjectConfiguration)(host, options.project);
    const npmPackageName = (0, devkit_1.readJson)(host, path.join(projectRoot, 'package.json')).name;
    let description;
    if (options.description) {
        description = options.description;
    }
    else {
        description = `${options.name} generator`;
    }
    return Object.assign(Object.assign(Object.assign({}, options), (0, devkit_1.names)(options.name)), { description,
        projectRoot,
        projectSourceRoot,
        npmScope,
        npmPackageName });
}
function addFiles(host, options) {
    const indexPath = `${options.projectSourceRoot}/generators/${options.fileName}/files/src/index.ts.template`;
    if (!host.exists(indexPath)) {
        host.write(indexPath, 'const variable = "<%= name %>";');
    }
    (0, devkit_1.generateFiles)(host, path.join(__dirname, './files/generator'), `${options.projectSourceRoot}/generators`, Object.assign(Object.assign({}, options), { generatorFnName: `${options.propertyName}Generator`, schemaInterfaceName: `${options.className}GeneratorSchema` }));
    if (options.unitTestRunner === 'none') {
        host.delete(path.join(options.projectSourceRoot, 'generators', options.fileName, `generator.spec.ts`));
    }
}
function createGeneratorsJson(host, projectRoot, projectName, skipLintChecks, skipFormat) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        (0, devkit_1.updateJson)(host, (0, devkit_1.joinPathFragments)(projectRoot, 'package.json'), (json) => {
            var _a;
            (_a = json.generators) !== null && _a !== void 0 ? _a : (json.generators = './generators.json');
            return json;
        });
        (0, devkit_1.writeJson)(host, (0, devkit_1.joinPathFragments)(projectRoot, 'generators.json'), {
            generators: {},
        });
        if (!skipLintChecks) {
            yield (0, generator_1.default)(host, {
                projectName,
                skipFormat,
            });
        }
    });
}
exports.createGeneratorsJson = createGeneratorsJson;
function updateGeneratorJson(host, options) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const packageJson = (0, devkit_1.readJson)(host, (0, devkit_1.joinPathFragments)(options.projectRoot, 'package.json'));
        const packageJsonGenerators = (_a = packageJson.generators) !== null && _a !== void 0 ? _a : packageJson.schematics;
        let generatorsPath = packageJsonGenerators
            ? (0, devkit_1.joinPathFragments)(options.projectRoot, packageJsonGenerators)
            : null;
        if (!generatorsPath) {
            generatorsPath = (0, devkit_1.joinPathFragments)(options.projectRoot, 'generators.json');
        }
        if (!host.exists(generatorsPath)) {
            yield createGeneratorsJson(host, options.projectRoot, options.project, options.skipLintChecks, options.skipFormat);
        }
        (0, devkit_1.updateJson)(host, generatorsPath, (json) => {
            var _a;
            let generators = (_a = json.generators) !== null && _a !== void 0 ? _a : json.schematics;
            generators = generators || {};
            generators[options.name] = {
                factory: `./src/generators/${options.fileName}/generator`,
                schema: `./src/generators/${options.fileName}/schema.json`,
                description: options.description,
            };
            // @todo(v17): Remove this, prop is defunct.
            if (options.name === 'preset') {
                generators[options.name]['x-use-standalone-layout'] = true;
            }
            json.generators = generators;
            return json;
        });
    });
}
function generatorGenerator(host, schema) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const options = normalizeOptions(host, schema);
        if ((0, has_generator_1.hasGenerator)(host, options.project, options.name)) {
            throw new Error(`Generator ${options.name} already exists.`);
        }
        addFiles(host, options);
        yield updateGeneratorJson(host, options);
        if (!options.skipFormat) {
            yield (0, devkit_1.formatFiles)(host);
        }
    });
}
exports.generatorGenerator = generatorGenerator;
exports.default = generatorGenerator;
exports.generatorSchematic = (0, devkit_1.convertNxGenerator)(generatorGenerator);
