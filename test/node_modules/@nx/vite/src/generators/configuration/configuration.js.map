{"version":3,"sources":["../../../../../../packages/vite/src/generators/configuration/configuration.ts"],"sourcesContent":["import {\n  convertNxGenerator,\n  formatFiles,\n  GeneratorCallback,\n  readProjectConfiguration,\n  runTasksInSerial,\n  Tree,\n} from '@nx/devkit';\n\nimport {\n  addOrChangeBuildTarget,\n  addOrChangeServeTarget,\n  addPreviewTarget,\n  createOrEditViteConfig,\n  deleteWebpackConfig,\n  editTsConfig,\n  findExistingTargetsInProject,\n  handleUnknownExecutors,\n  handleUnsupportedUserProvidedTargets,\n  moveAndEditIndexHtml,\n  TargetFlags,\n  UserProvidedTargetName,\n} from '../../utils/generator-utils';\n\nimport initGenerator from '../init/init';\nimport vitestGenerator from '../vitest/vitest-generator';\nimport { ViteConfigurationGeneratorSchema } from './schema';\n\nexport async function viteConfigurationGenerator(\n  tree: Tree,\n  schema: ViteConfigurationGeneratorSchema\n) {\n  const tasks: GeneratorCallback[] = [];\n\n  const { targets, projectType, root } = readProjectConfiguration(\n    tree,\n    schema.project\n  );\n  let buildTargetName = 'build';\n  let serveTargetName = 'serve';\n  let testTargetName = 'test';\n\n  schema.includeLib ??= projectType === 'library';\n\n  // Setting default to jsdom since it is the most common use case (React, Web).\n  // The @nx/js:lib generator specifically sets this to node to be more generic.\n  schema.testEnvironment ??= 'jsdom';\n\n  /**\n   * This is for when we are converting an existing project\n   * to use the vite executors.\n   */\n  let projectAlreadyHasViteTargets: TargetFlags = {};\n\n  if (!schema.newProject) {\n    const userProvidedTargetName: UserProvidedTargetName = {\n      build: schema.buildTarget,\n      serve: schema.serveTarget,\n      test: schema.testTarget,\n    };\n\n    const {\n      validFoundTargetName,\n      projectContainsUnsupportedExecutor,\n      userProvidedTargetIsUnsupported,\n      alreadyHasNxViteTargets,\n    } = findExistingTargetsInProject(targets, userProvidedTargetName);\n    projectAlreadyHasViteTargets = alreadyHasNxViteTargets;\n    /**\n     * This means that we only found unsupported build targets in that project.\n     * The only way that buildTarget is defined, means that it is supported.\n     *\n     * If the `unsupported` flag was false, it would mean that we did not find\n     * a build target at all, so we can create a new one.\n     *\n     * So we only throw if we found a target, but it is unsupported.\n     */\n    if (!validFoundTargetName.build && projectContainsUnsupportedExecutor) {\n      throw new Error(\n        `The project ${schema.project} cannot be converted to use the @nx/vite executors.`\n      );\n    }\n\n    if (\n      alreadyHasNxViteTargets.build &&\n      (alreadyHasNxViteTargets.serve || projectType === 'library') &&\n      alreadyHasNxViteTargets.test\n    ) {\n      throw new Error(\n        `The project ${schema.project} is already configured to use the @nx/vite executors.\n        Please try a different project, or remove the existing targets \n        and re-run this generator to reset the existing Vite Configuration.\n        `\n      );\n    }\n\n    /**\n     * This means that we did not find any supported executors\n     * so we don't have any valid target names.\n     *\n     * However, the executors that we may have found are not in the\n     * list of the specifically unsupported executors either.\n     *\n     * So, we should warn the user about it.\n     */\n\n    if (\n      !projectContainsUnsupportedExecutor &&\n      !validFoundTargetName.build &&\n      !validFoundTargetName.serve &&\n      !validFoundTargetName.test\n    ) {\n      await handleUnknownExecutors(schema.project);\n    }\n\n    /**\n     * There is a possibility at this stage that the user has provided\n     * targets with unsupported executors.\n     * We keep track here of which of the targets that the user provided\n     * are unsupported.\n     * We do this with the `userProvidedTargetIsUnsupported` object,\n     * which contains flags for each target (whether it is supported or not).\n     *\n     * We also keep track of the targets that we found in the project,\n     * through the findExistingTargetsInProject function, which returns\n     * targets for build/serve/test that use supported executors, and\n     * can be converted to use the vite executors. These are the\n     * kept in the validFoundTargetName object.\n     */\n    await handleUnsupportedUserProvidedTargets(\n      userProvidedTargetIsUnsupported,\n      userProvidedTargetName,\n      validFoundTargetName\n    );\n\n    /**\n     * Once the user is at this stage, then they can go ahead and convert.\n     */\n\n    buildTargetName = validFoundTargetName.build ?? buildTargetName;\n    serveTargetName = validFoundTargetName.serve ?? serveTargetName;\n\n    if (projectType === 'application') {\n      moveAndEditIndexHtml(tree, schema, buildTargetName);\n    }\n\n    deleteWebpackConfig(\n      tree,\n      root,\n      targets?.[buildTargetName]?.options?.webpackConfig\n    );\n\n    editTsConfig(tree, schema);\n  }\n\n  const initTask = await initGenerator(tree, {\n    uiFramework: schema.uiFramework,\n    includeLib: schema.includeLib,\n    compiler: schema.compiler,\n    testEnvironment: schema.testEnvironment,\n  });\n  tasks.push(initTask);\n\n  if (!projectAlreadyHasViteTargets.build) {\n    addOrChangeBuildTarget(tree, schema, buildTargetName);\n  }\n\n  if (!schema.includeLib) {\n    if (!projectAlreadyHasViteTargets.serve) {\n      addOrChangeServeTarget(tree, schema, serveTargetName);\n    }\n    if (!projectAlreadyHasViteTargets.preview) {\n      addPreviewTarget(tree, schema, serveTargetName);\n    }\n  }\n\n  createOrEditViteConfig(tree, schema, false, projectAlreadyHasViteTargets);\n\n  if (schema.includeVitest) {\n    const vitestTask = await vitestGenerator(tree, {\n      project: schema.project,\n      uiFramework: schema.uiFramework,\n      inSourceTests: schema.inSourceTests,\n      coverageProvider: 'c8',\n      skipViteConfig: true,\n      testTarget: testTargetName,\n      skipFormat: true,\n    });\n    tasks.push(vitestTask);\n  }\n\n  if (!schema.skipFormat) {\n    await formatFiles(tree);\n  }\n\n  return runTasksInSerial(...tasks);\n}\n\nexport default viteConfigurationGenerator;\nexport const configurationSchematic = convertNxGenerator(\n  viteConfigurationGenerator\n);\n"],"names":["viteConfigurationGenerator","configurationSchematic","tree","schema","tasks","targets","projectType","root","readProjectConfiguration","project","buildTargetName","serveTargetName","testTargetName","includeLib","testEnvironment","projectAlreadyHasViteTargets","newProject","userProvidedTargetName","build","buildTarget","serve","serveTarget","test","testTarget","validFoundTargetName","projectContainsUnsupportedExecutor","userProvidedTargetIsUnsupported","alreadyHasNxViteTargets","findExistingTargetsInProject","Error","handleUnknownExecutors","handleUnsupportedUserProvidedTargets","moveAndEditIndexHtml","deleteWebpackConfig","options","webpackConfig","editTsConfig","initTask","initGenerator","uiFramework","compiler","push","addOrChangeBuildTarget","addOrChangeServeTarget","preview","addPreviewTarget","createOrEditViteConfig","includeVitest","vitestTask","vitestGenerator","inSourceTests","coverageProvider","skipViteConfig","skipFormat","formatFiles","runTasksInSerial","convertNxGenerator"],"mappings":"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"}