"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RULE_NAME = void 0;
const devkit_1 = require("@nx/devkit");
const create_eslint_rule_1 = require("../utils/create-eslint-rule");
const project_graph_utils_1 = require("../utils/project-graph-utils");
const runtime_lint_utils_1 = require("../utils/runtime-lint-utils");
const path_1 = require("path");
const internal_1 = require("@nx/js/src/internal");
const semver_1 = require("semver");
const js_1 = require("@nx/js");
const package_json_utils_1 = require("../utils/package-json-utils");
exports.RULE_NAME = 'dependency-checks';
exports.default = (0, create_eslint_rule_1.createESLintRule)({
    name: exports.RULE_NAME,
    meta: {
        type: 'suggestion',
        docs: {
            description: `Checks dependencies in project's package.json for version mismatches`,
            recommended: 'error',
        },
        fixable: 'code',
        schema: [
            {
                type: 'object',
                properties: {
                    buildTargets: [{ type: 'string' }],
                    ignoredDependencies: [{ type: 'string' }],
                    checkMissingDependencies: { type: 'boolean' },
                    checkObsoleteDependencies: { type: 'boolean' },
                    checkVersionMismatches: { type: 'boolean' },
                },
                additionalProperties: false,
            },
        ],
        messages: {
            missingDependency: `The "{{projectName}}" uses the following packages, but they are missing from the "{{section}}":{{packageNames}}`,
            obsoleteDependency: `The "{{packageName}}" package is not used by "{{projectName}}".`,
            versionMismatch: `The version specifier does not contain the installed version of "{{packageName}}" package: {{version}}.`,
            missingDependencySection: `Dependency sections are missing from the "package.json" but following dependencies were detected:{{dependencies}}`,
        },
    },
    defaultOptions: [
        {
            buildTargets: ['build'],
            checkMissingDependencies: true,
            checkObsoleteDependencies: true,
            checkVersionMismatches: true,
            ignoredDependencies: [],
        },
    ],
    create(context, [{ buildTargets, ignoredDependencies, checkMissingDependencies, checkObsoleteDependencies, checkVersionMismatches, },]) {
        var _a;
        if (!context.parserServices.isJSON) {
            return {};
        }
        const fileName = (0, devkit_1.normalizePath)(context.getFilename());
        // support only package.json
        if (!fileName.endsWith('/package.json')) {
            return {};
        }
        const projectPath = (0, devkit_1.normalizePath)(globalThis.projectPath || devkit_1.workspaceRoot);
        const sourceFilePath = (0, runtime_lint_utils_1.getSourceFilePath)(fileName, projectPath);
        const { projectGraph, projectRootMappings, projectFileMap } = (0, project_graph_utils_1.readProjectGraph)(exports.RULE_NAME);
        if (!projectGraph) {
            return {};
        }
        const sourceProject = (0, runtime_lint_utils_1.findProject)(projectGraph, projectRootMappings, sourceFilePath);
        // check if source project exists
        if (!sourceProject) {
            return {};
        }
        // check if library has a build target
        const buildTarget = buildTargets.find((t) => { var _a; return (_a = sourceProject.data.targets) === null || _a === void 0 ? void 0 : _a[t]; });
        if (!buildTarget) {
            return {};
        }
        // gather helper dependencies for @nx/js executors
        const helperDependencies = (0, js_1.getHelperDependenciesFromProjectGraph)(devkit_1.workspaceRoot, sourceProject.name, projectGraph);
        // find all dependencies for the project
        const npmDeps = (0, internal_1.findProjectsNpmDependencies)(sourceProject, projectGraph, buildTarget, {
            helperDependencies: helperDependencies.map((dep) => dep.target),
        }, (0, package_json_utils_1.removePackageJsonFromFileMap)(projectFileMap));
        const projDependencies = Object.assign(Object.assign({}, npmDeps.dependencies), npmDeps.peerDependencies);
        const expectedDependencyNames = Object.keys(projDependencies);
        const projPackageJsonPath = (0, path_1.join)(devkit_1.workspaceRoot, sourceProject.data.root, 'package.json');
        (_a = globalThis.projPackageJsonDeps) !== null && _a !== void 0 ? _a : (globalThis.projPackageJsonDeps = (0, package_json_utils_1.getAllDependencies)(projPackageJsonPath));
        const projPackageJsonDeps = globalThis.projPackageJsonDeps;
        const rootPackageJsonDeps = (0, package_json_utils_1.getAllDependencies)((0, path_1.join)(devkit_1.workspaceRoot, 'package.json'));
        function validateMissingDependencies(node) {
            if (!checkMissingDependencies) {
                return;
            }
            const missingDeps = expectedDependencyNames.filter((d) => !projPackageJsonDeps[d] && !ignoredDependencies.includes(d));
            if (missingDeps.length) {
                context.report({
                    node: node,
                    messageId: 'missingDependency',
                    data: {
                        packageNames: missingDeps.map((d) => `\n    - ${d}`).join(''),
                        section: node.key.value,
                        projectName: sourceProject.name,
                    },
                    fix(fixer) {
                        missingDeps.forEach((d) => {
                            projPackageJsonDeps[d] =
                                rootPackageJsonDeps[d] || projDependencies[d];
                        });
                        const deps = node.value.properties;
                        const mappedDeps = missingDeps
                            .map((d) => `\n    "${d}": "${projPackageJsonDeps[d]}"`)
                            .join(',');
                        if (deps.length) {
                            return fixer.insertTextAfter(deps[deps.length - 1], `,${mappedDeps}`);
                        }
                        else {
                            return fixer.insertTextAfterRange([node.value.range[0] + 1, node.value.range[1] - 1], `${mappedDeps}\n  `);
                        }
                    },
                });
            }
        }
        function validateVersionMatchesInstalled(node, packageName, packageRange) {
            if (!checkVersionMismatches) {
                return;
            }
            if (projDependencies[packageName] === '*' ||
                (0, semver_1.satisfies)(projDependencies[packageName], packageRange)) {
                return;
            }
            context.report({
                node: node,
                messageId: 'versionMismatch',
                data: {
                    packageName: packageName,
                    version: projDependencies[packageName],
                },
                fix: (fixer) => fixer.replaceText(node, `"${packageName}": "${rootPackageJsonDeps[packageName] || projDependencies[packageName]}"`),
            });
        }
        function reportObsoleteDependency(node, packageName) {
            if (!checkObsoleteDependencies) {
                return;
            }
            context.report({
                node: node,
                messageId: 'obsoleteDependency',
                data: { packageName: packageName, projectName: sourceProject.name },
                fix: (fixer) => {
                    const isLastProperty = node.parent.properties[node.parent.properties.length - 1] === node;
                    const index = node.parent.properties.findIndex((n) => n === node);
                    if (index > 0) {
                        const previousNode = node.parent.properties[index - 1];
                        return fixer.removeRange([
                            previousNode.range[1] + (isLastProperty ? 0 : 1),
                            node.range[1] + (isLastProperty ? 0 : 1),
                        ]);
                    }
                    else {
                        const parent = node.parent;
                        // it's the only property
                        if (isLastProperty) {
                            return fixer.removeRange([
                                parent.range[0] + 1,
                                parent.range[1] - 1,
                            ]);
                        }
                        else {
                            return fixer.removeRange([
                                parent.range[0] + 1,
                                node.range[1] + 1,
                            ]);
                        }
                    }
                },
            });
        }
        function validateDependenciesSectionExistance(node) {
            if (!expectedDependencyNames.length ||
                !expectedDependencyNames.some((d) => !ignoredDependencies.includes(d))) {
                return;
            }
            if (!node.properties ||
                !node.properties.some((p) => [
                    'dependencies',
                    'peerDependencies',
                    'devDependencies',
                    'optionalDependencies',
                ].includes(p.key.value))) {
                context.report({
                    node: node,
                    messageId: 'missingDependencySection',
                    data: {
                        dependencies: expectedDependencyNames
                            .map((d) => `\n- "${d}"`)
                            .join(),
                    },
                    fix: (fixer) => {
                        expectedDependencyNames.sort().reduce((acc, d) => {
                            acc[d] = rootPackageJsonDeps[d] || projDependencies[d];
                            return acc;
                        }, projPackageJsonDeps);
                        const dependencies = Object.keys(projPackageJsonDeps)
                            .map((d) => `\n    "${d}": "${projPackageJsonDeps[d]}"`)
                            .join(',');
                        if (!node.properties.length) {
                            return fixer.replaceText(node, `{\n  "dependencies": {${dependencies}\n  }\n}`);
                        }
                        else {
                            return fixer.insertTextAfter(node.properties[node.properties.length - 1], `,\n  "dependencies": {${dependencies}\n  }`);
                        }
                    },
                });
            }
        }
        return {
            ['JSONExpressionStatement > JSONObjectExpression > JSONProperty[key.value=/^(dev|peer|optional)?dependencies$/i]'](node) {
                return validateMissingDependencies(node);
            },
            ['JSONExpressionStatement > JSONObjectExpression > JSONProperty[key.value=/^(dev|peer|optional)?dependencies$/i] > JSONObjectExpression > JSONProperty'](node) {
                const packageName = node.key.value;
                const packageRange = node.value.value;
                if (ignoredDependencies.includes(packageName)) {
                    return;
                }
                if (expectedDependencyNames.includes(packageName)) {
                    return validateVersionMatchesInstalled(node, packageName, packageRange);
                }
                else {
                    return reportObsoleteDependency(node, packageName);
                }
            },
            ['JSONExpressionStatement > JSONObjectExpression'](node) {
                return validateDependenciesSectionExistance(node);
            },
        };
    },
});
