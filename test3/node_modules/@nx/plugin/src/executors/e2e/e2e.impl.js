"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nxPluginE2EExecutor = void 0;
const tslib_1 = require("tslib");
require("dotenv/config");
const devkit_1 = require("@nx/devkit");
const jest_impl_1 = require("@nx/jest/src/executors/jest/jest.impl");
// TODO(v18): remove this
function nxPluginE2EExecutor(options, context) {
    return tslib_1.__asyncGenerator(this, arguments, function* nxPluginE2EExecutor_1() {
        var _a, e_1, _b, _c;
        const { target } = options, jestOptions = tslib_1.__rest(options, ["target"]);
        devkit_1.output.warn({
            title: `"@nx/plugin:e2e" is deprecated and will be removed in Nx 18`,
            bodyLines: [
                'Use the "@nx/jest:jest" executor instead and set the following:',
                `"dependsOn": ["${target}"]`,
            ],
        });
        let success;
        try {
            for (var _d = true, _e = tslib_1.__asyncValues(runBuildTarget(target, context)), _f; _f = yield tslib_1.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                _c = _f.value;
                _d = false;
                const _ = _c;
                try {
                    success = yield tslib_1.__await(runTests(jestOptions, context));
                }
                catch (e) {
                    devkit_1.logger.error(e.message);
                    success = false;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) yield tslib_1.__await(_b.call(_e));
            }
            finally { if (e_1) throw e_1.error; }
        }
        return yield tslib_1.__await({ success });
    });
}
exports.nxPluginE2EExecutor = nxPluginE2EExecutor;
function runBuildTarget(buildTarget, context) {
    return tslib_1.__asyncGenerator(this, arguments, function* runBuildTarget_1() {
        var _a, e_2, _b, _c;
        const graph = yield tslib_1.__await((0, devkit_1.createProjectGraphAsync)());
        const { project, target, configuration } = (0, devkit_1.parseTargetString)(buildTarget, graph);
        const buildTargetOptions = (0, devkit_1.readTargetOptions)({ project, target, configuration }, context);
        const targetSupportsWatch = Object.keys(buildTargetOptions).includes('watch');
        try {
            for (var _d = true, _e = tslib_1.__asyncValues(yield tslib_1.__await((0, devkit_1.runExecutor)({ project, target, configuration }, targetSupportsWatch ? { watch: false } : {}, context))), _f; _f = yield tslib_1.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                _c = _f.value;
                _d = false;
                const output = _c;
                if (!output.success)
                    throw new Error('Could not compile application files.');
                yield yield tslib_1.__await(output.success);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) yield tslib_1.__await(_b.call(_e));
            }
            finally { if (e_2) throw e_2.error; }
        }
    });
}
function runTests(jestOptions, context) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { success } = yield (0, jest_impl_1.jestExecutor)(Object.assign(Object.assign({}, jestOptions), { watch: false }), context);
        return success;
    });
}
exports.default = nxPluginE2EExecutor;
