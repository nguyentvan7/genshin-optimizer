"use strict";
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    validateTypes: function() {
        return validateTypes;
    },
    registerPaths: function() {
        return registerPaths;
    }
});
const _js = require("@nx/js");
const _path = require("path");
const _buildablelibsutils = require("@nx/js/src/utils/buildable-libs-utils");
const _internal = require("@nx/js/src/internal");
async function validateTypes(opts) {
    const result = await (0, _js.runTypeCheck)({
        workspaceRoot: opts.workspaceRoot,
        tsConfigPath: (0, _path.join)(opts.workspaceRoot, opts.tsconfig),
        mode: 'noEmit'
    });
    await (0, _js.printDiagnostics)(result.errors, result.warnings);
    if (result.errors.length > 0) {
        throw new Error('Found type errors. See above.');
    }
}
function registerPaths(projectRoot, options, context) {
    var _options;
    const tsConfig = (0, _path.resolve)(projectRoot, 'tsconfig.json');
    var _buildLibsFromSource;
    (_buildLibsFromSource = (_options = options).buildLibsFromSource) != null ? _buildLibsFromSource : _options.buildLibsFromSource = true;
    if (!options.buildLibsFromSource) {
        const { dependencies  } = (0, _buildablelibsutils.calculateProjectDependencies)(context.projectGraph, context.root, context.projectName, context.targetName, context.configurationName);
        const tmpTsConfig = (0, _buildablelibsutils.createTmpTsConfig)(tsConfig, context.root, projectRoot, dependencies);
        (0, _internal.registerTsConfigPaths)(tmpTsConfig);
    } else {
        (0, _internal.registerTsConfigPaths)(tsConfig);
    }
}

//# sourceMappingURL=executor-utils.js.map